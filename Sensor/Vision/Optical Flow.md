## 概述
1. 视频图像序列中，物体、表面或边缘在视觉上的运动模式。
2. 是一个二维向量场，其中每一个向量都是一个运动矢量，表示了图像上某个点在连续两帧之间的“视运动”情况。
3. 简单来说，上一帧图像中的每一个像素，移动到了下一帧图像的哪个位置以及移动的方向和速度是多少。
# 假设及公式
## 亮度恒定假设
对于场景中的同一个点，在连续的两帧图像中，其像素强度（亮度）是不变的。
### 公式
第一帧中坐标 (x, y) 处的像素亮度是 I(x, y, t)，那么在经过一小段时间 dt 后，该点移动到了 (x+dx, y+dy)，其亮度 I(x+dx, y+dy, t+dt) 应该与原来相等。
$$ \\ I(x, y, t) = I(x+dx, y+dy, t+dt)$$
### 意义
意味着场景的光照条件是稳定的，并且物体的反光属性不会改变。
## 空间平滑假设
一个物理表面上的相邻点通常具有相似的运动。因此，图像中一个小邻域内的像素，其光流向量是相似的（或平滑变化的）。
### 意义
1. 如果没有这个假设，对于大面积的无纹理区域（如一面白墙），将无法确定其内部像素的运动，因为所有像素看起来都一样。
2. 这个假设允许利用有纹理区域的运动信息来“推断”无纹理区域的运动。
## 光流约束方程
基于亮度恒定假设，通过泰勒级数展开并忽略高阶项，可以推导出一个基本的光流方程，称为光流约束方程 (Optical Flow Constraint Equation)
### 公式
$$I_x u + I_y v + I_t = 0$$
或者写成：
$$\nabla I \cdot \vec{V} + I_t = 0$$
1. $I_x = \frac{\partial I}{\partial x}$：图像在 x 方向的梯度（亮度变化）。
2. $I_y = \frac{\partial I}{\partial y}$：图像在 y 方向的梯度（亮度变化）。
3. $I_t = \frac{\partial I}{\partial t}$：图像随时间变化的梯度（两帧之间的亮度差）。
4. $u, v$：光流向量 $\vec{V} = (u, v)$ 的两个分量，即像素在 x 和 y 方向的移动速度。这是我们要求解的未知数。

# 算法
## 孔径问题
1. 想象一下通过一个小孔观察一根很长的斜向移动的棍子。只能看到棍子在视野范围内上下移动，而无法确定它是否同时在左右移动。
2. 也就是说，只能确定垂直于边缘的运动，无法确定沿着边缘的运动。
3. 为了解决这个问题，需要引入更多的约束条件，这也就催生了不同的光流估计算法。
## Lucas-Kanade (LK) 算法 - 局部法
### 思想
利用空间平滑假设。假设在一个局部的小窗口（例如 3x3）内，所有像素的光流向量 (u, v) 都是相同的
### 解决方法
1. 对于窗口内的每个像素，都列出一个光流约束方程。
2. 这样，对于一个 N x N 的窗口，我们就得到了 N^2 个方程，而未知数仍然只有 u 和 v 两个。
3. 这就构成了一个超定方程组 (Overdetermined System)。
4. 通过最小二乘法，可以为这个窗口求解出一个最优的光流向量 (u, v)。
### 特点
1. 稀疏光流：通常只对图像中具有显著特征的点（如角点）进行计算，因为这些区域梯度变化丰富，解更稳定。
2. 速度快：计算量相对较小。
3. 对大位移不鲁棒：如果物体运动速度过快，超出了小窗口的范围，亮度恒定假设会失效，导致跟踪失败。解决方法是使用图像金字塔 (Image Pyramid)，在不同分辨率的图像上进行计算。
4. 应用：非常适合用于特征点跟踪。
## Horn-Schunck (HS) 算法 - 全局法
### 思想
1. 同样利用空间平滑假设，但将其作为一个全局约束。
2. 构建一个全局能量函数，并试图最小化这个函数。
### 能量函数
$$ \\ E = \iint \left( (I\_x u + I\_y v + I\_t)^2 + \alpha^2 (|\nabla u|^2 + |\nabla v|^2) \right) dx dy$$
1. 第一项 (数据项)：$(I_x u + I_y v + I_t)^2$，要求计算出的光流尽可能满足亮度恒定假设。
2. 第二项 (平滑项)：$\alpha^2 (|\nabla u|^2 + |\nabla v|^2)$，要求整个光流场是平滑的，即相邻像素的光流向量差异要小。
3. $\alpha$：正则化系数，用于平衡数据项和平滑项的重要性。
4. 通过变分法、迭代求解等方式，找到使全局能量 E 最小的 $u(x, y)$ 和 $v(x, y)$ 分布。
### 特点
1. 稠密光流 (Dense Optical Flow)：为图像中的每一个像素都计算一个光流向量。
2. 结果更平滑、完整：由于全局约束，结果通常更符合物理世界的运动。
3. 计算量大：需要迭代求解，速度较慢。
4. 边缘模糊：平滑项可能会导致不同运动物体交界处的边缘变得模糊。

# 实践
## 草坪
### 问题
1. 高度重复的微观纹理：匹配特征点时，可能把 A 点的草叶特征错误地识别为了 B 点，导致出现小范围的“漂移”或“抖动”。
2. 动态干扰：光流的核心工作前提是地面静止，当风吹过草坪时，是整个地面在晃动，会错误地将草的运动解算成是无人机自身的移动。
3. 光影变化：云彩的飘动会导致大面积的光照强度变化，无人机的影子也会在草坪上移动，可能导致定位突然的跳动。
### 解决
1. 适当提升飞行高度：捕捉到更大范围的草坪，即更大尺度、更独特的纹理图案。
2. 多传感器数据融合
## 跑道
### 问题
1. 严重缺乏纹理：光流找不到可以“锚定”的点，因此完全无法计算位移。
2. 强方向性的重复特征：白色分道线是为数不多的特征，但这些线是笔直且平行的。\
（1）沿线飞行时：无人机可以很好地锁定线条，保持前后方向的稳定。\
（2）横向漂移时：无人机很难感知到侧向的微小移动，一旦它漂移到另一条车道线，可能导致定位的突然“跳变”。
3. 表面反光与眩光：阳光照射下，塑胶跑道表面可能会产生眩光或高光反射。过曝的区域会使摄像头传感器饱和，丢失所有纹理细节。
### 解决反光
1. 识别高光区域：目标是生成一个二值图像，其中白色代表高光区域，黑色正常区域。
2. 镜面高光通常具有极高的亮度和极低的饱和度。无论物体本身是什么颜色，高光区域的颜色信息都会丢失，趋近于白色。
3. 将输入的 BGR 图像转换为 HSV/HSL 色彩空间，使用 `cv2.inRange()` 根据阈值生成二值 Mask
4. 优化 Mask：闭运算，先膨胀后腐蚀，填充掉 Mask 内部的小黑洞；开运算，先腐蚀后膨胀，可以去除 Mask 外部的孤立小白点。
5. 图像修复：`cv2.inpaint()` 内置了两种算法。\
（1）NS (Navier-Stokes based Method)：基于流体动力学，从边界向内传播信息，速度较快。\
（2）TELEA (Alexandru Telea's Method)：基于快速行进算法，优先修复靠近轮廓的区域，效果通常更平滑、更自然。