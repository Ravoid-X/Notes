## 死锁（pending）
### 定义
如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发。
### 资源
需要排他性使用的对象，主要分为可抢占资源（可以从拥有它的进程中抢占而不会造成其他影响，如内存）和不可抢占资源（除非引起错误或者异常，否则进程无法抢占指定资源，如光盘）。
### 可能的情况，以下四个必须同时发生
1. 互斥条件：每个资源都被分配给了一个进程或者资源是可用的。
2. 保持和等待条件：已经获取资源的进程被认为能够获取新的资源。
3. 不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，只能由占有它的进程释放。
4. 循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。
## 解决方法
### 鸵鸟算法
如果死锁发生的频次很低，可能不会修复。
### 死锁检测
1. 每当有资源请求时就去检测，这种方式会占用昂贵的 CPU 时间。
2. 每隔 k 分钟检测一次，或者当 CPU 使用率降低到某个标准下去检测更合理。
### 死锁恢复
1. 临时将某个资源从持有者转移到另一个进程，使用完后又送回，通常不采取。
2. 设置检测点，不仅包含存储映像，还包含资源状态。发生死锁时回滚到上一个时间点，在此时对其进行资源重分配。
3. 直接杀死一个或多个死锁进程。
### 死锁避免
1. 银行家算法：判断请求是否会使系统进入一种不安全的状态。如果是，就拒绝请求。
2. 破坏互斥条件：必须占用非共享资源，会导致系统有很大局限性。
3. 破坏保持和等待条件：让所有的进程开始执行前请求全部的资源。或者进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。
4. 破坏不可抢占条件：虚拟化。
5. 破坏循环等待条件：制定一个标准，一个进程在任何时候只能使用一种资源。或将所有的资源统一编号，进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。

## 扩展
### 两阶段提交(two-phase locking)。
1. 一阶段是进程尝试一次锁定它需要的所有记录。第二阶段执行更新并释放锁。
2. 如果第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。
3. 这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。
### 通信死锁
1. 进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。
2. 假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来。
3. 解决：超时制度，信息被发出后，发送者就会启动一个定时器，如果超时但还没有返回消息，就会认为消息已经丢失并重新发送。
### 活锁
当进程意识到它不能获取所需要的下一个锁时，就会尝试释放已经获得的锁，然后等待非常短的时间再次尝试获取。两个并行进程可能会一直重复此操作。
### 饥饿
假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程可能永远得不到服务。