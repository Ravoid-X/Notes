## 进程（pending）
1. 进程是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。
2. 每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器（仅有一个）中。当程序运行结束后，物理程序计数器就会它放回进程的逻辑计数器中。
### 进程创建
1. UNIX：使用系统调用fork来创建新的进程，调用后一个父进程和子进程会有相同的内存映像，相同的环境字符串和相同的打开文件。
2. Windows：CreateProcess，会处理流程创建并将正确的程序加载到新的进程中。父进程的地址空间和子进程的地址空间是不同的。
### 进程终止
1. UNIX：正常退出为exit，被其他进程杀死为kill。
2. Windows：正常退出为ExitProcess，被其他进程杀死为TerminateProcess。
### 进程层次
1. UNIX：进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作。
2. Windows：所有进程都是平等的。
### 进程状态
1. 运行态：运行态指的就是进程实际占用 CPU 时间片运行时。
2. 就绪态：就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态。
3. 阻塞态：除非某种外部事件发生，否则进程不能运行。
### 进程实现
1. 为了执行进程间的切换，会维护进程表(process table)。每个进程占用一个进程表项。
2. 该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息。

## 进程间通信
### 信号 signal
1. 可以从键盘或者访问不存在的位置等地方产生异步事件信号，并通过 shell 将任务发送给子进程。
2. 进程可以选择忽略发送过来的信号，但不能忽略SIGSTOP和SIGKILL信号。SIGSTOP通知当前正在运行的进程执行关闭操作，SIGKILL通知当前进程应该被杀死。
### 管道 pipe
1. 在两个进程之间可以建立一个通道，一个进程向通道里写入字节流，另一个进程从管道中读取字节流。
2. 管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。
3. 两个应用程序不知道管道的存在，一切都由 shell 管理和控制。
### 共享内存 shared memory
1. 多个进程可以访问公共内存空间，类似线程间通信。\
2. 创建共享内存段或者使用已创建的共享内存段shmget()；进程附加到已经创建的内存段中shmat()；从已连接的共享内存段分离进程shmdt()；对共享内存段执行控制操作shmctl()。
### 先入先出队列 FIFO
1. 通常被称为命名管道(Named Pipes)，具有支持文件和独特API，在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。
2. 未命名管道没有备份文件，操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。
3. 写入的第一个字节是读取的第一个字节。
### 消息队列 Message Queue
1. 按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。
2. 严格模式就像是 FIFO 先入先出队列，消息顺序发送，顺序读取。还有非严格模式，消息的顺序性不是非常重要。
### 套接字 Socket
1. 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。
2. 一般用于两个进程之间的网络通信，网络套接字需要来自诸如TCP（传输控制协议）或较低级别UDP（用户数据报协议）等基础协议的支持。
3. 顺序包套接字(Sequential Packet Socket)：为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。
4. 数据报套接字(Datagram Socket)：支持双向数据流，接受消息的顺序与发送者可能不同。
5. 流式套接字(Stream Socket)：工作方式类似于电话对话，提供双向可靠的数据流。
6. 原始套接字(Raw Socket)： 可以使用原始套接字访问基础通信协议。

## 线程
1. 有程序计数器（用来记录接着要执行哪一条指令）、寄存器、堆栈、状态。
### 比进程比较
1. 多线程之间会共享同一块地址空间和所有可用数据。
2. 更轻量级，在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。
3. 如果线程都是 CPU 密集型的，那么并不能增强性能，但如果存在着大量的计算和I/O 处理，多个线程能彼此重叠进行，加快程序的执行速度。
### 调用
1. 当前某个单线程通过调用一个库函数（如 thread_create）创建新的线程。函数会要求指定名称，创建的线程通常会返回一个线程标识符，即新线程的名字。
2. 当一个线程完成工作后，可以调用一个函数（如 thread_exit）来退出。紧接着线程消失，状态变为终止，不能再进行调度。
3. 在某些线程的运行过程中，可以调用函数（如 thread_join），表示一个线程可以等待另一个线程退出。
### 实现
1. 用户空间：整个线程包放在用户空间中，内核不知道线程的存在。如pthread_create, pthread_exit, pthread_join 和 pthread_yield。
2. 内核空间：当某个线程希望创建或撤销一个线程时，它会进行一个系统调用，更新线程表的来完成线程创建或销毁工作。内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同。
3. 混合实现
