# 头部格式
<img src="../Pic/Com/TCP_head_type.jpg" style="width:380px;padding:10px;"/>

32位序号：建立连接时，计算机生成的随机数通过SYN包传给接收方，每发送一次数据，就会累加一次这个数据字节数的大小，解决网络包乱序问题\
32位确认应答号：期望收到对方下一个报文的第一个数据字节的序号,即当前收到消息包的序号+数据字节数+1，解决丢包问题\
4位TCP报头长度：指出TCP头部有多长\
6个boolean值标志位：\
&emsp;&emsp;URG：紧急指针是否有效，此报文段中有紧急数据\
&emsp;&emsp;ACK：确认号是否有效，规定在连接建立后所有报文的传输都必须把ACK置1\
&emsp;&emsp;PSH：提示接收端应用程序立刻从TCP缓冲区把数据读走\
&emsp;&emsp;RST：对方要求重新建立连接，把携带RST标识的称为复位报文段\
&emsp;&emsp;SYN：连接建立时用来同步序号。当SYN=1，ACK=0，连接请求报文，若同意连接，则响应报文中使SYN=1，ACK=1，称为同步报文段\
&emsp;&emsp;FIN：当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放，把携带FIN标识的称为结束报文\
16位窗口大小：进行流量窗口控制\
16位校验和：检验数据是否一致\
16位紧急指针：标识哪部分数据是紧急数据
# 可靠传输机制
## 确认应答
1. 向对方发送一个数据报，对方要返回一个确认应答的数据报，有了确认应答，才可以继续发送数据
2. 实现方式：序号和确认序号保证了响应应答针对的是哪一条消息的应答
## 超时重传
1. 因网络拥堵等原因，超过一定时间，还没有收到确认应答的数据报，需要重新发送
2. 超时时间设置的太长，导致重传的效率；设置太短，导致频繁发送重复的数据
3. 系统会动态计算超时时间，机制如下\
超时以500ms为一个单位，每次判定超时重发的时间都是500ms的整数倍\
重发一次，仍然不能收到应答，等待2*500ms后再进行重传\
仍然等不到应答，等待4*500ms进行重传，以此类推，以指数形式增长\
累积到一定重传次数，TCP协议认为网络或者对端主机出现异常，强制关闭连接
4. 去重操作:接收的数据会放在操作系统内核的接收缓冲区中，TCP会根据序号检查数据是否在缓冲区中已经存在，存在则丢弃，不存在则存放
## 连接管理（三次握手，四次挥手）
### 握手
<img src="../Pic/Com/TCP-3-connect.jpg" style="width:400px;padding:10px;"/>

1. 客户端向服务端发送SYN，申请建立客户端到服务端的连接
2. 服务端返回ACK（第一次SYN的应答）和SYN，申请建立服务端到客户端的连接
3. 客户端收到数据，状态置为ESTABLISHED，表示客户端到服务端连接建立完成，并且发送ACK（第二次SYN的应答），服务端收到数据，状态置为ESTABLISHED，表示服务端到客户端的连接建立完成
### 挥手
<img src="../Pic/Com/TCP-4-cut.jpg" style="width:280px;padding:10px;"/>

1. 客户端发送FIN到服务端，申请关闭客户端到服务端的连接
2. 服务端收到FIN状态置为CLOSE_WAIT，并返回ACK应答（系统实现，TCP协议栈默认执行的）
3. 服务端发送FIN到客户端，申请关闭服务端到客户端的连接（程序调用socket.close发送）
4. 客户端收到FIN返回ACK应答，并进入TIME_WAIT时间等待状态，客户端等待一段时间后，状态置为CLOSED，服务端收到应答后，状态置为CLOSED
### 问题
1. 为什么服务端不将ACK和FIN合并一起发送，形成三次挥手呢？\
答：ACK是操作系统内核响应的（立即执行），而此时服务端还可能在继续发送数据，待处理完数据后由程序调用close方法后才发送FIN
2. 为什么客户端要等待一段时间状态才置为CLOSED？\
答：如果客户端给服务端的ACK丢包后，服务端得重新给和客户端发送FIN，此时客户端得给服务端应答，所以此时状态不能置为CLOSED，得等待一段时间（2MSL，MSL为网络上任意两点传输的最大时间）确保服务端收到客户端的应答 
## 流量控制
1. 问题：接收端主机处理数据的速度有限，如果发送端发送数据太快，导致接收端缓冲区被填满，继续发送数据就会造成丢包
2. 解决：接收端将自己剩余缓冲区大小存入“16位窗口大小”字段，通过ACK通知发送端\
   发送端根据接收到这个窗口的大小，控制自己的发送速度\
   如果接收缓冲区满了，就会将窗口设置为0，发送端不再发送数据，而是定期发送一个窗口探测报文，让接收端将窗口大小告诉发送端
## 拥塞控制
1. 问题：刚发送数据时，由于中间结点的网络情况不清楚，如发送大量数据，可能造成大量丢包
2. 解决：引入慢启动的方式，先发少量数据，再决定按照多大速度发送数据
3. 拥塞窗口:刚开始时，拥塞窗口为1，收到一个ACK拥塞窗口加1,指数式增长快速接近丢包极限\
   每次发送数据时，拥塞窗口和流量窗口较小的值作为实际发送的窗口，即滑动窗口
4. 慢启动阈值:当拥塞窗口超过这个阈值，不再按照指数方式增长，而是按照线性方式
   网络拥塞时，拥塞窗口置1，慢启动阈值变为拥塞窗口/2，重新开始增长\
<img src="../Pic/Com/TCP-block-control.jpg" style="width:450px;padding:10px;"/>

# 效率机制
## 滑动窗口
1. 问题：每一个发送的数据都对应有一个ACK确认应答，效率太差
2. 解决：采用滑动窗口，即一次性发送多个数据\
<img src="../Pic/Com/TCP-slide-window.jpg" style="width:480px;padding:10px;"/>

## 高速重发控制
### 情况1
1. 问题：数据已经收到，返回的ACK应答丢包\
<img src="../Pic/Com/TCP-package-loss1.jpg" style="width:380px;padding:10px;"/>

2. 解决：部分ACK丢了不要紧，因为可以通过后续的ACK进行确认
### 情况2
1. 问题：发送数据丢包\
   <img src="../Pic/Com/TCP-package-loss2.jpg" style="width:380px;padding:10px;"/>

2. 当1001~2000这段报文丢失后，发送端一直会收到1001这样的ACK\
   发送端主机连续三次收到相同的ACK如1001应答，那发送端主机就会重新发送1001~2000数据\
   接收端收到1001~2000数据后，再次返回的ACK应答就是7001了，因为2001~7000数据都已经接收到了，被放到接收端操作系统内核的接收缓冲区了
## 延迟应答
1. 接收端主机接收到数据时立刻返回ACK应答，这时候返回的流量窗口比较小
2. 等待待接收端处理完一部分数据，可以将流量窗口设置较大值，这样网咯吞吐量大，效率高
3. 延迟设置：数量限制，每隔n个包就应答一次；时间限制，超过最大延迟时间，应答一次
## 捎带应答
服务端接收到客户端的消息后，因为延迟应答机制，导致ACK不一定立即返回，可能ACK返回的时机和应用代码中返回响应的时机重合了，此时九江
# 问题情况
## 粘包问题
1. 对于应用层来说，一连串的字节数据，不知道怎么算一个完整的应用层数据包
2. 明确包的界限\
   对于定长的包，每次都按照固定大小读取即可\
   对于变长的包，可以在包与包之间明确分隔符（应用协议，程序员自己定，只要保证分隔符和正文不起冲突即可）
## 异常情况
进程终止：进程终止会释放文件描述符，仍然可以发送FIN，和正常关闭没有什么区别
机器重启：和进程终止的情况相同
机器掉电/网线断开：接收端认为连接还在，一旦接收端有写入操作，接收端发现连接已经不在了就会进行reset，即使没有写入操作，TCP自己也内置了一个保活定时器，会定期询问对方是否还在，如果对方不在，也会把连接释放
另外，应用层的某些协议，也有一些这样的检测机制，例如HTTP长连接中，也会定期检测对方的状态，例如QQ，在QQ断线之后，也会定期尝试重新连接 
# 支持的协议
HTTP、HTTPS、SSH、Telnet、FTP、SMTP