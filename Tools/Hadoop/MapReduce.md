## 概述 （pending）
1. 分布式计算框架，主要由两部分组成：编程模型和运行时环境。其中，编程模型为用户提供了非常易用的编程接口，其他比较复杂的工作，如节点间的通信、节点失效、数据切分等，全部由MapReduce运行时环境完成。
2. 诞生于搜索领域，主要解决搜索引擎面临的海量数据处理扩展性差的问 题。它的实现很大程度上借鉴了谷歌MapReduce的设计思想，包括简化编程接口、 提高系统容错性等。
### 优点
1. 易于编程：Hadoop将所有并行程序均需要关注的设计细节抽象成公共模块并交由系统实现，而用户只需专注于自己的应用程序逻辑实现。
2. 良好扩展性：当数据量增加到一定程度后，现有的集群可能已经无法满足其计算能力和存储能力，这时候管理员可能期望通过添加机器以达到线性扩展集群能力的目的。
3. 高容错性：随着集群规模的增加，故障率（包括磁盘损坏、机器宕机、节点间通信失败等硬件故障和坏数据或者用户程序 bug 产生的软件故障）会显著增加，进而导致任务失败和数据丢失的可能性增加。为此，Hadoop 通过计算迁移或者数据迁移等策略提高集群的可用性与容错性。
4. 适合海量数据：适合PB级以上海量数据的离线处理， 可以实现上千台服务器集群并发工作，提供数据处理能力。
### 缺点
1. 不擅长实时计算：无法像MySQL一样，在毫秒或者秒级内返回结果。
2. 不擅长流式计算：流式计算的输入数据是动态的，而MapReduce的输入数据集是静态的，不能动态变化。这是因为MapReduce自身的设计特点决定了数据源必须是静态的。
3. 不擅长DAG（有向图）计算：多个应用程序存在依赖关系，后一个应用程序的输入为前一个的输出。在这种情况下，MapReduce并不是不能做，而是使用后，每个MapReduce作业的输出结果都会写入到磁盘，会造成大量的磁盘IO，导致性能非常的低下。
### 核心思想
1. 由两个阶段组成：Map 阶段 和 Reduce 阶段
2. 第一个阶段的 MapTask 并发实例，完全并行运行，互不相干。
3. 第二个阶段的 ReduceTask 并发实例互不相干，但是他们的数据依赖于上一个阶段的所有 MapTask 并发实例的输出。
4. 如果用户的业务逻辑非常复杂，那就只能多个 MapReduce 程序，串行运行。
5. 每一个 Map 阶段和 Reduce 阶段都可以由多个 Map Task 和 Reduce Task。
6. map() 函数以 <key,value> 对作为输入，产生另外一系列 <key,value> 作为中间输出写入本地磁盘。
7. MapReduce 框架会自动将这些中间数据按照 key 值进行聚集，且 key 值相同（用户可设定聚集策略，默认情况下是对 key 值进行哈希取模）的数据被统一交给 reduce() 函数处理。
8. reduce() 函数以key及对应的value列表作为输入，经合并 key 相同的 value 值后， 产生另外一系列 <key,value> 对作为最终输出写入 HDFS。
9. 对外提供了 5 个可编程组件，分别是 InputFormat、Mapper、Partitioner、Reducer 和 OutputFormat。
## 工作机制

### 作业提交

### 作业初始化

### 任务的分配

### 任务的执行

### 作业完成

## 组成部分工作原理

### MapTask

### Reduce

### shuffle

<img src="../../pic/Tools/Hadoop/hdfs-write.png" style="width:500px;padding:10px;"/>