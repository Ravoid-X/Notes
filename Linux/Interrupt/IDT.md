## 概述
1. 当一个中断信号通过 APIC 等硬件通路最终抵达目标 CPU 核心时，CPU 会立即启动一套由硬件固化的响应流程。
2. 流程的核心是将一个简单的中断号（称为向量）精确地映射到内核中特定的代码入口点。
3. 中断描述符表（IDT）正是实现这一映射的关键数据结构。
## 中断描述符表 (IDT)
x86 架构特有的一个数据结构，扮演着中断向量和中断服务例程（Interrupt Service Routine, ISR）地址之间的桥梁。
### 结构与定位
1. 由 256 个门描述符（Gate Descriptor）组成的数组，每个描述符对应一个 0 到 255 的中断向量。
2. CPU 通过专用的 IDTR 寄存器来定位 IDT 在内存中的基地址和大小限制。   
### 内核初始化
1. 尽管 BIOS 在启动时会建立一个初始的 IDT，但 Linux 内核在接管系统控制权后。会通过 trap_init 等函数构建自己的 IDT。
2. 并使用 LIDT 汇编指令将新 IDT 的地址加载到 IDTR 寄存器中，从而完全控制系统的中断和异常处理。   
### 向量分配
1. 向量 0-31 被保留用于处理器定义的异常（如除零、页错误等）。
2. 向量 32-255 则可用于外部硬件中断（IRQs）和软件中断。
3. 历史上，Linux 使用向量 128（0x80）作为传统的 32 位系统调用接口。
## IDT 门描述符
在 64 位长模式下，每个 IDT 门描述符为 16 字节，其内部结构复杂而精密，包含了 CPU 进行控制转移所需的所有信息。
### 偏移量 (Offset) 与段选择子 (Selector)
1. 这两个字段共同构成了中断服务例程入口点的 64 位完整虚拟地址。
2. 段选择子必须指向全局描述符表（GDT）中一个有效的代码段描述符，定义了代码执行的基地址和属性。   
### 中断门
1. 主要用于处理外部硬件中断。
2. 通过中断门进行控制转移时，CPU 会自动清除 EFLAGS 寄存器中的中断允许标志位（IF），从而屏蔽后续的可屏蔽中断。
3. 这可以防止在处理一个中断时被同级别的其他中断打扰，是保证中断处理原子性的重要硬件机制。
### 陷阱门
1. 主要用于处理异常和软件中断（如系统调用）。
2. 通过陷阱门进行控制转移时，CPU 不会改变 IF 标志位的状态。
3. 这允许在处理一个异常（如一个调试断点）时，系统仍然能够响应更高优先级的硬件中断。
### 特权级 (DPL) 与栈切换
1. 描述符权限级别（Descriptor Privilege Level, DPL）字段定义了允许通过软件指令（如 INT）触发此中断的最低特权级别。
2. 当一个中断导致特权级发生变化时（最典型的是从用户态 Ring 3 切换到内核态 Ring 0），CPU 会执行一次自动的、硬件保障的栈切换。
3. CPU 会从任务状态段（Task State Segment, TSS）中获取新的内核栈地址，然后将旧的用户栈指针（SS:RSP）、EFLAGS、代码段指针（CS:RIP）以及可能的错误码依次压入新的内核栈中。
4. 中断栈表（Interrupt Stack Table, IST）机制还允许为特定的、极其关键的异常（如 NMI、双重故障）指定专用的、独立的内核栈，以防止因常规内核栈溢出而导致的系统崩溃。
## 中断处理流程
当 CPU 核心接收到一个中断向量后，会严格按照以下硬件逻辑执行
1. 完成当前正在执行的指令
2. 将当前的 RFLAGS、CS 和 RIP 寄存器压入当前栈中  
3. 对于某些特定的异常，硬件还会将一个错误码压栈  
4. CPU 使用中断向量号作为索引，在 IDTR 指向的 IDT 中定位到对应的门描述符
5. CPU 读取描述符，进行 DPL 等权限检查。如果发生特权级提升，则执行栈切换。
6. CPU 将描述符中指定的新的段选择子和偏移量加载到 CS 和 RIP 寄存器中，这使得程序的执行流跳转到了内核中预设的低级中断处理入口点。   
7. 如果通过的是一个中断门，此时可屏蔽中断已被硬件自动禁止。
8. 内核的中断处理代码开始执行
9. 处理完成后，代码会执行 IRET（或 64 位的 IRETQ）指令。该指令会从栈中弹出之前保存的寄存器状态，原子地恢复到被中断前的执行上下文中。