## 概述
1. 当中断发生，CPU 跳转到内核的中断处理程序时，代码的执行环境发生了一种根本性的变化。
2. 这种特殊的执行环境被称为中断上下文（Interrupt Context）或硬中断上下文（Hardirq Context）
3. 基于延迟处理的思想，将中断处理流程划分为两个阶段：上半部 (Top Half) 与下半部 (Bottom Half)
## 特性
### 原子性
中断上下文中的代码执行是“原子”的，它打断了系统中的其他所有活动（在该CPU上）。
### 非进程关联
不隶属于任何特定的进程。虽然 current 宏可能指向被中断的那个进程，但这仅仅是一个巧合，中断处理程序不能依赖于这个进程的状态。
### 不可睡眠/阻塞
1. 由于没有关联的进程上下文，中断上下文中的代码绝对不能执行任何可能导致睡眠或阻塞的操作。
2. 例如，不能调用 schedule() 来主动放弃 CPU，也不能试图获取信号量或互斥锁。如果中断上下文睡眠了，系统将无法唤醒它。
### 禁止访问用户空间
中断处理程序运行在内核空间，并且不能安全地访问被中断进程的用户空间内存，因为此时的内存映射可能是不完整的或不一致的。
### 中断屏蔽
1. 为了保证中断处理程序的执行不被干扰，当一个硬中断处理程序运行时，当前CPU上的中断通常是被屏蔽的。
2. 至少，引发该中断的 IRQ 线会被屏蔽，以防止同一中断的重入。
### 延迟处理
1. 上述严格的约束，特别是中断屏蔽，决定了中断处理程序必须尽可能快地执行完毕。
2. 通常，这个时间窗口被要求在100微秒以内，如果一个中断处理程序执行时间过长，这会导致\
（1）其他设备的中断请求得不到及时处理，影响系统的实时响应能力\
（2）对于边沿触发的中断，如果在一个中断被处理期间，同一个中断源又产生了新的中断，而中断线仍被屏蔽，那么新的中断事件可能丢失。\
（3）整个系统的并发性受到严重影响，表现为系统卡顿或无响应
## 上半部
在 request_irq() 中注册的、直接响应硬件中断的那个函数，即硬中断处理程序（Hardirq）。它的职责被严格限定在最小范围内：
1. 快速应答硬件，告知中断控制器中断已被接收。
2. 读取或写入关键的设备寄存器（例如，清除中断状态位）。
3. 如果设备有数据到达（如网卡），将数据从有限的硬件缓冲区快速拷贝到内存中的软件缓冲区。
4. 调度下半部来执行后续的处理工作。
5. 尽快退出，以便 CPU 可以重新开启中断，响应其他事件 
## 下半部
1. 由上半部调度，在稍后的某个时间点执行。
2. 下半部执行时，中断通常是开启的，使得它可以在一个限制较少的环境中完成更复杂的工作。
3. 下面具体比较三种核心的下半部机制：软中断、tasklet 和工作队列。
### 权衡
1. 上半部与下半部的划分，是延迟与吞吐量之间权衡的经典范例。 
2. 上半部的设计目标是极致的低延迟，它要以最快的速度响应硬件，防止数据丢失或硬件状态错误。
## 软中断
最底层、性能最高的一种
### 实现机制
1. 在编译时静态定义，数量固定（通常为 32 个），通过一个名为 softirq_vec 的全局数组进行管理。
2. 上半部通过调用 raise_softirq() 来触发软中断，该函数实际上只是在一个 per-CPU 的位掩码中设置相应的比特位。
3. 内核会在几个关键时间点（如从硬件中断处理返回时、从系统调用返回时）检查这个位掩码，并通过 do_softirq() 函数执行所有挂起的软中断处理程序。
4. 为防止软中断处理长时间霸占 CPU 而饿死用户进程，如果软中断处理循环次数过多或耗时过长，剩余的工作会被转移到一个 per-CPU 的内核线程 ksoftirqd 中继续执行。
### 执行上下文
1. 软中断处理程序运行在中断上下文中。
2. 意味着和硬中断处理程序一样，是原子执行的，不能睡眠或阻塞。
### 并发模型
1. 软中断是可重入的。同一个软中断处理程序可以同时在多个CPU上并发执行。
2. 因此，软中断处理程序必须自行处理同步问题，通常需要使用自旋锁来保护其共享数据。
### 适用场景
1. 由于其高性能和静态定义的特性，软中断被保留给内核中最核心、对时间最敏感、发生频率最高的子系统使用。
2. 典型例子包括网络数据包的接收和发送（NET_TX_SOFTIRQ, NET_RX_SOFTIRQ）、内核定时器的处理（TIMER_SOFTIRQ）以及 RCU（Read-Copy-Update）的回收处理（RCU_SOFTIRQ）。
3. 内核明确不鼓励设备驱动程序直接使用软中断。
## tasklet
构建在软中断之上的一种更易于使用的下半部机制
### 实现机制
1. 内核使用了两个专用的软中断向量来实现 tasklet\
（1）HI_SOFTIRQ：用于高优先级，通过 tasklet_hi_schedule 调度\
（2）TASKLET_SOFTIRQ：用于普通优先级，通过 tasklet_schedule 调度
2. 与软中断不同，tasklet 可以动态地创建和销毁（通过 tasklet_init 或 DECLARE_TASKLET 宏）。
### 执行上下文
与软中断一样，tasklet 也运行在中断上下文中，不能睡眠 
### 并发模型
1. 核心优势在于其简化的并发模型，其是串行化的，同一个 tasklet（即同一个 tasklet_struct 实例）在任何时刻都保证只在一个 CPU 上运行。
2. 如果一个 tasklet 已经被调度但尚未执行，再次对它进行调度将被忽略。
3. 即使在 SMP 系统上，内核也保证了同一个 tasklet 的处理函数不会与自身并发。
4. 然而，不同类型的 tasklet 可以并行地在不同的 CPU 上运行。
5. 这种设计极大地简化了驱动程序的编写，因为开发者通常无需担心 tasklet 处理函数内部的重入问题。
### 适用场景
设备驱动程序中最常用的下半部机制，适用于那些处理工作量较大、但不需要睡眠或阻塞的场景
## 工作队列
最高层、最灵活的下半部机制
### 实现机制
1. 将延迟的工作放入一个队列中，由一个或多个专用的内核线程（称为 kworker）来异步执行。
2. 开发者定义一个 struct work_struct 结构体，其中包含一个指向处理函数的指针，然后通过 schedule_work() 等 API 将这个工作项提交到系统默认的工作队列或自定义的工作队列中。
3. 现代的并发管理工作队列系统通过共享的 per-CPU 工作者池来高效地管理这些内核线程 。
### 执行上下文
1. 这是工作队列与软中断和tasklet最本质的区别：它的处理函数运行在进程上下文中。
2. 因为工作是在一个正常的内核线程中执行的，所以它拥有一个完整的进程上下文，是可调度的、可抢占的，并且最重要的是，可以睡眠。
### 并发模型
1. 工作队列的处理函数就像一个普通的内核线程函数。
2. 它可以使用所有常规的内核同步原语，如互斥锁、信号量等，来进行阻塞式的同步
### 适用场景
1. 适用于任何可能需要睡眠的延迟工作。
2. 包括需要进行可能阻塞的I/O操作（如访问文件系统）、分配大量内存（可能触发页面回收而睡眠）、或者需要获取互斥锁等场景。
3. 工作队列提供了最大的灵活性，但其代价是较高的延迟，因为它涉及到内核线程的调度和上下文切换。