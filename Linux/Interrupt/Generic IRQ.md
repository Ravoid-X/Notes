## 概述
1. 在 CPU 硬件将控制权交给内核的初始入口点之后，内核的通用 IRQ 子系统便开始接管。
2. 软件抽象层，目标是屏蔽底层各种中断控制器（PIC、APIC、以及各种嵌入式系统中的 GIC 等）的硬件差异，为设备驱动程序提供一个统一、可移植的中断处理接口。
## struct irq_desc：IRQ 的核心描述符
内核为系统中的每一个中断号（IRQ number）都维护一个 struct irq_desc 描述符，其关键字段包括
### handle_irq
1. 函数指针，指向该 IRQ 的高层中断流处理函数
2. 当底层架构相关的汇编代码完成初始的上下文保存后，就会调用 desc->handle_irq()
3. 内核预定义了一系列通用的流处理函数，如 handle_level_irq（电平触发中断），handle_edge_irq（边沿触发中断），实现了处理特定类型中断的通用逻辑流程。
### chip
1. 指向一个 irq_chip 结构体，该结构体封装了与底层中断控制器硬件直接交互的低层操作函数。
2. 本质上是一个函数指针的集合，包含了如 irq_mask（屏蔽中断）、irq_unmask（解除屏蔽）、irq_ack（应答中断）和 irq_eoi（发送中断结束信号）等原子操作。
3. 这种设计使得高层的 handle_irq 可以不关心具体的硬件细节，只需调用 chip 结构中标准化的接口即可。
### action
1. 一个指向该 IRQ 注册的中断处理动作链表的头节点的指针
2. 对于非共享中断，该链表只有一个节点。
3. 对于共享中断，所有注册在该 IRQ 上的处理程序都会以 irqaction 结构的形式串联在这个链表中
## 注册中断服务例程 (ISR)
设备驱动程序通过调用 request_irq() 或其现代变体 request_threaded_irq() 来为其中断注册一个处理函数。request_irq() 的内部流程大致如下：
1. 接收 IRQ 号、处理函数指针（handler）、标志位（flags）、设备名和唯一的设备ID（dev_id）作为参数。   
2. 内核分配一个 struct irqaction 结构体，并用传入的参数填充它。dev_id 对于区分共享中断线上的不同设备至关重要 。   
3. 根据 IRQ 号找到对应的 struct irq_desc 描述符。
4. 获取该描述符的自旋锁，以保证操作的原子性。
5. 检查是否可以注册。如果该 IRQ 线已被占用，且现有的处理程序和新的请求者都没有设置 IRQF_SHARED 标志，则注册失败，返回错误码-EBUSY。   
6. 如果允许共享，则将新创建的 irqaction 结构体插入到 irq_desc 的 action 链表中。   
7. 如果这是该 IRQ 上的第一个注册者，内核会调用 irq_chip 中的 irq_startup 函数，在硬件层面使能该中断线。
## 处理共享中断
1. 注册时必须在 flags 参数中指定 IRQF_SHARED 标志
2. 共享中断发生时，高层流处理函数会调用 handle_irq_event()，该函数会遍历 action 链表，依次调用每一个注册的处理函数。
3. 每个处理函数都必须有能力判断中断是否由自己的设备产生，通常由读取设备的状态寄存器来完成。
4. 如果不是自己的设备，处理函数必须立即返回 IRQ_NONE。如果是，则执行相应的处理，并返回IRQ_HANDLED
## 示例
1. 一个特定硬件平台（如某个 ARM SoC）的中断控制器驱动，会实现一个 struct irq_chip，并将其中的函数指针指向操作该硬件的实际代码。
2. 在系统初始化阶段，架构相关的代码会将这个 chip 结构与相应的 irq_desc 关联起来，并根据中断的物理特性（如电平触发），将 handle_irq 指针设置为一个通用的策略函数，比如 handle_level_irq。
3. 当中断发生时，通用的 handle_level_irq 函数被调用。它本身并不知晓底层硬件的具体型号，只是按照既定策略，通过 desc->chip 中的函数指针（如 desc->chip->irq_mask(data)）来调用底层的硬件操作。