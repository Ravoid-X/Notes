## 概述
1. 调度器的主要目标往往是相互冲突的：最大化CPU利用率和吞吐量，同时最小化周转时间、等待时间和响应时间。
2. 关键目标是公平性，确保所有进程都能获得公平的 CPU 份额，从而防止饥饿现象的发生。
3. 通过模块化的调度类来实现这些目标，不同的调度类服务于不同类型的进程（如实时、普通），并按优先级顺序被查询。

## 完全公平调度器（CFS）
1. 自 Linux 内核 2.6.23 版本起，CFS 成为普通进程的默认调度器。
2. 核心原则是每个进程都以 $1/n$ 的速度并行运行，其中 $n$ 是可运行任务的数量。
### 虚拟运行时间
1. 由于真实硬件一次只能运行一个任务，CFS 使用 vruntime 概念来追踪一个进程已经运行了多长时间。
2. vruntime 是进程的实际运行时间根据其优先级（nice值）进行加权归一化后的结果。
3. 一个任务的 vruntime 存储在其 task_struct 的 p->se.vruntime 字段中。
### 调度决策
总是选择 vruntime 最小的任务投入运行。即是到目前为止获得 CPU 时间最少的任务。
### 红黑树
1. CFS 的运行队列是一个按时间排序的红黑树，所有可调度的实体都根据它们的 vruntime 值在树中排序。
2. 树的最左侧节点永远是 vruntime 最小的任务，查找最左节点为 $O(1)$ （因为最左节点被缓存），而插入和删除操作为 $O(\log N)$
### 动态时间片
没有固定的时间片。一个任务的运行时间取决于两个可调参数：sched_latency_ns 和 sched_min_granularity_ns
1. sched_latency_ns：调度器的一个目标延迟，即一个“调度周期”，理想情况下所有可运行任务都应在此周期内至少运行一次。
2. sched_min_granularity_ns：这保证了每个任务运行的最小时间，以防止因任务过多而导致时间片过小，从而避免过高的上下文切换开销。
### 计算逻辑
1. 如果可运行任务数乘以 sched_min_granularity_ns 小于sched_latency_ns，则每个任务的时间片约为 sched_latency_ns / n
2. 如果任务数非常多，导致计算出的时间片小于 sched_min_granularity_ns，那么每个任务的时间片将被固定为 sched_min_granularity_ns，而调度周期则会相应延长至 n * sched_min_granularity_ns。

## 实时与专用调度
Linux 为具有不同需求的任务提供了替代的调度策略，SCHED_FIFO、SCHED_RR 与 SCHED_BATCH 的优先级高于 CFS。
### NORMAL
优先级范围 100-139 (由nice值映射)，即上面的 CFS
### BATCH
1. 优先级范围 100-139 (由nice值映射)，如 CPU 密集型的后台批处理作业
2. 针对吞吐量优化，调度器假定其非交互性，减少抢占，可能给予更长运行时间。
### FIFO
1. 优先级范围 1-99 (实时)，严格的实时任务，需要立即响应，且任务自己管理执行时间。
2. 静态优先级，非抢占式（除非被更高优先级任务抢占），无时间片。
### RR
1. 优先级范围 1-99 (实时)，如需要在同等实时优先级任务间公平分配 CPU 时间的实时应用。
2. 静态优先级，带时间片的抢占式调度，在同优先级任务间轮转。
### IDLE
1. 优先级范围 N/A，极低优先级，仅在系统完全空闲时运行。
2. 如系统后台维护等非关键任务

## 优先级框架
### 实时优先级
用于 SCHED_FIFO 和 SCHED_RR 策略，范围从 1（最低）到 99（最高）。任何实时进程总是会抢占任何普通进程。
### 普通优先级
1. 对于普通进程，优先级通过 nice 值进行管理
2. nice 值：这是一个用户空间的概念，范围从-20（最高）到+19（最低）
3. 静态优先级：内核将 nice 值映射到内部的静态优先级范围 100到139，计算公式为 static_prio = 120 + nice
### 分析
1. nice 值不再是一个决定谁先运行的绝对等级，而是作为一个权重，用于调节进程 vruntime 累积的速率。
2. 高优先级的进程会获得较大的权重。当 CFS 计算 vruntime 的增量时，会用实际运行时间除以该权重（或乘以一个与权重相关的比例因子）。
3. 高优先级进程的 vruntime 增长得更慢。意味着它将在红黑树的“最左侧”停留更长时间，从而有效地获得更多的 CPU 时间。
4. 每个nice值的变化大约对应10%的CPU时间变化。