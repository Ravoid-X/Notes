## 概述
Linux 系统中运行成千上万个进程，采用了“会话 -> 进程组 -> 进程”的三层管理模型，形成了一个清晰的层级结构。
## 进程组
1. 为了方便对一组相关的进程进行信号传递和管理。
2. 当在 Shell 中执行一条命令，尤其是包含管道符（|）的命令时，所有参与管道的进程通常会被放入同一个进程组。
3. 可以通过 kill 命令向整个进程组发送信号。例如，`kill -SIGTERM -<pgid>`
4. 创建进程组的第一个进程被称为进程组领头进程，其 PID 通常就是该进程组的 PGID
## 会话
1. 将一组相关的进程组与一个控制终端关联起来，实现更高级别的进程管理。
2. 通常始于用户登录到一个终端。此时，登录 Shell 进程会成为一个会话领头进程，并创建一个新的会话。该会话中的所有进程组都与这个终端相关联。
3. 一个会话最多只能有一个控制终端。控制终端是用户与系统交互的接口，负责接收用户的输入并将其转换为信号发送给会话中的进程。
4. 前台与后台进程组：在一个会话中，任意时刻只有一个进程组可以处于前台，其余的则处于后台。\
（1）前台进程组: 可以接收来自控制终端的输入。\
（2）后台进程组: 在后台静默运行，不能直接接收终端输入。如果后台进程尝试读取终端输入，它将被挂起。

## 作业控制
1. 为用户提供在单个 Shell 会话中同时管理多个任务的能力。
2. 在 Shell 语境中，一个作业通常对应一个进程组。作业控制使得用户可以方便地启动、停止、恢复以及在前后台之间切换作业。
### 指令
1. & (后台运行): 在命令末尾加上 & 可以让该命令（作业）在后台启动
```
sleep 100 &
```
2. jobs (查看作业): 列出当前 Shell 会话中的所有作业及其状态
```
$ jobs
[1]+  Running                 sleep 100 &
```
3. fg (切换到前台): 将一个后台作业切换到前台运行
```
fg %1  # 将作业号为 1 的作业切换到前台
```
4. bg (切换到后台): 将一个被挂起的作业切换到后台继续运行
```
# 运行一个命令，然后按 Ctrl+Z 挂起它
$ sleep 200
^Z
[2]+  Stopped                 sleep 200

# 将被挂起的作业放到后台运行
$ bg %2
[2]+ sleep 200 &
```
5. kill (发送信号): 可以通过作业号向作业（即进程组）发送信号
```
kill %1  # 向作业号为 1 的作业发送终止信号
```

## 总结
1. 进程组是实现对多个进程进行统一信号控制的基础。
2. 会话则将进程组与终端关联起来，并引入了前后台的概念。
3. 作业控制是 Shell 提供给用户的友好接口，让我们能够轻松地驾驭和管理会话中的多个任务。