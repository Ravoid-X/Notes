## 概述
1. 定义为“执行中的程序”——一个需要CPU时间、内存、I/O设备等系统资源的活动实体。
2. 操作系统分配资源的基本单位，每个进程都拥有一个唯一的进程 PID、独立的地址空间以及至少一个控制线程。
3. 多个进程可以执行同一个程序，但每个实例都是独立的，在各自的私有地址空间内拥有程序的副本。
4. 程序本身只是存储在磁盘上的被动指令集合，而进程则是这些指令被加载到内存并由CPU执行时的动态、活动表现。

## 核心属性
### 并发
1. 操作系统管理多个任务在同一时间段内取得进展的能力。
2. 在单核 CPU上，这是通过快速的上下文切换实现的，从而创造出任务同时执行的错觉。
### 并行
1. 多个任务在物理上同时执行，这必须依赖于多核处理器等硬件支持。
2. 并行执行必然意味着并发，但反之则不然。
### 独立进程
其执行结果仅取决于输入状态，因此是确定性的。
### 协作进程
进程共享状态和资源，其执行结果具有不确定性，因为它取决于进程间的相对执行顺序。
### 资源竞争
1. 协作关系不可避免地导致了资源竞争，是操作系统设计中的一个核心挑战。
2. 可能导致竞态条件、阻塞、饥饿和死锁等严重问题。

## task_struct
1. 内核通过一个名为 task_struct 的 C 语言结构体来管理进程，通常被称为进程控制块（PCB）。
2. 系统中运行的每个任务都由一个动态分配的 task_struct 实例来表示。
### 关键字段
1. state：一个整数，表示进程的当前状态（例如，TASK_RUNNING、TASK_INTERRUPTIBLE），这是调度器决策的基础。   
2. pid：唯一的进程标识符。内核维护了一个以 PID 为键的哈希表，可通过 find_task_pid() 函数进行高效查找。   
2. mm 和 active_mm：指向 mm_struct 结构的指针，该结构描述了进程的虚拟地址空间。内核线程没有自己的地址空间（mm 为 NULL），因此其 active_mm 会指向前一个运行的用户进程的地址空间，以最大限度地减少地址转换后备缓冲（TLB）的刷新开销。   
3. p->next_task 和 p->prev_task：这两个指针将系统内所有的 task_struct 实例连接成一个循环双向链表。这使得内核可以通过 for_each_task() 宏轻松地遍历系统中的每一个进程。   
4. personality 和 exec_domain：这些字段允许 Linux 模拟其他 UNIX 变体的系统调用行为，以提供兼容性。   

## 进程层级
1. Linux 中的进程被组织成一个严格的树状层级结构。
2. 除了系统启动的第一个进程 init（PID 为 1）之外，每个进程都有一个创建它的父进程。
3. 这种父子关系通过 task_struct 内的链表进行管理\ 
（1）children：一个指针，作为包含该进程所有直接子进程的链表的头节点或锚点。\
（2）sibling：每个子进程的 task_struct 中都有一个 sibling 指针，将自己链接到同一父进程的下一个子进程，从而形成一个兄弟链表。