## 进程创建
### fork()
1. 创建一个与父进程几乎完全相同的新子进程，写时复制机制。
2. 高效且安全，是标准的 UNIX 进程创建方式。
3. 在父进程中，返回新创建子进程的进程 ID；在子进程中，返回 0；如果出现错误，返回一个负值；
### vfork()
1. 子进程会借用父进程的地址空间，而父进程则被挂起，直到子进程调用exec()或_exit()
2. 避免了复制页表的开销，但子进程对共享地址空间的任何修改都会影响父进程。
3. 在现代 COW 机制下，vfork() 的性能优势已微不足道，其使用已不被推荐。
### clone()
1. Linux 特有的底层系统调用，是所有进程和线程创建功能的基础。
2. 具有高度的灵活性，允许调用者精确指定哪些资源（如内存空间、文件描述符、信号处理器）被共享，哪些被复制。
3. 标准库中的 fork() 和 pthread_create() 函数都是对 clone() 的封装。
## exec() 系列
1. 根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，就是在调用进程内部执行一个可执行文件。
2. 可执行文件既可以是二进制文件，也可以是任何 Linux 下可执行的脚本文件。
### 函数原型
1. execv 开头的函数是以"char *argv[]"形式传递命令行参数
2. execl 开头的函数采用了 list 的方式
3. 只有 execve 是系统调用，其它都是在此基础上经过包装的库函数。
4. 执行成功后不会返回，因为调用进程的实体已经被新的内容取代，只有进PID 等信息仍保持原样。
5. 调用失败时，会设置 errno 并返回 -1，然后从原程序的调用点接着往下执行。
```
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
```
### 使用情况
如果一个进程想执行另一个程序，它就可以 fork 或 vfork 出一个新进程，然后调用任何一个 exec 函数。

## 进程状态
### 运行态
1. 正在 CPU 上执行，或在运行队列中等待被调度，PS 状态码 R。
2. 进入条件：进程创建；被调度器选中
3. 退出条件：时间片用尽；阻塞；被抢占
### 可中断睡眠
1. 进程正在等待某个事件（如 I/O 完成、锁），可以被信号唤醒，PS 状态码 S
2. 进入条件：等待资源（如 read(), select()）
3. 退出条件：等待的事件发生；收到信号
### 不可中断睡眠
1. 进程正在等待，但不能被信号唤醒，通常用于短暂的、关键的硬件交互，PS 状态码 D
2. 进入条件：等待磁盘 I/O 等不可中断操作
3. 退出条件：等待的事件发生
### 停止态
1. 进程执行被暂停，PS 状态码 T
2. 进入条件：收到 SIGSTOP, SIGTSTP 信号（如 Ctrl+Z）
3. 退出条件：收到 SIGCONT 信号 
### 僵尸态
1. 进程已终止，但其父进程尚未通过 wait() 系统调用回收其退出状态，PS 状态码 Z
2. 进入条件：调用 exit() 或被信号终止
3. 退出条件：父进程调用 wait() 或 waitpid()

## 进程终止
### 正常终止
1. 进程通过调用  exit() 库函数来正常终止
2. 该函数会执行一系列清理操作，如刷新标准 I/O 缓冲区、调用通过 atexit() 注册的函数，然后才调用底层的 _exit() 系统调用。
3. _exit() 将一个整数退出状态码传递给内核，释放进程占用的资源，并将进程转换为 TASK_ZOMBIE，等待父进程回收。
### 由信号终止
1. SIGTERM (15)：kill 命令发送的默认信号。是一个终止请求，进程可以捕获此信号以执行关闭操作（如保存数据、关闭网络连接），然后再退出。   
2. SIGKILL (9)：不能被捕获、阻塞或忽略。内核会立即终止目标进程，不允许其进行任何清理工作。这是处理无响应进程的最后手段。   
3. SIGHUP (1)="：即“挂断”信号。最初用于指示控制终端已断开，现在通常用于通知守护进程重新加载其配置文件。
## 特殊情况
1. 进程的异步终止带来了两个特殊的进程状态：僵尸进程和孤儿进程。
2. 这些状态并非错误，而是内核为解决异步清理问题而设计的方案。
### 孤儿进程
1. 当一个子进程终止会变成僵尸进程，直到其父进程通过调用 wait() 或 waitpid() 来回收它。
2. 如果父进程未能调用 wait()，僵尸进程就会累积，并持续占用进程表中的一个条目，最终可能耗尽进程表资源。
### 僵尸进程
1. 如果一个父进程在子进程之前终止，那么这个子进程就成了孤儿进程。
2. 内核会自动将它们的父进程设置为 init 进程。init 进程被设计为会持续调用 wait()