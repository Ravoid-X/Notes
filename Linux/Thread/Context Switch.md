## 概述
1. 实现多任务处理的基础机制，操作系统保存当前运行进程的状态，并恢复下一个被调度运行进程状态的过程。
2. 由内核调度器执行，进程的“上下文”包括CPU的通用寄存器、浮点寄存器、指令指针（ip）、栈指针（sp）以及其他处理器特定的状态。

## 触发条件
1. 自愿切换：进程主动放弃CPU，例如等待I/O操作完成或等待同步锁。
2. 非自愿切换（抢占）：一个更高优先级的进程变为可运行状态；当前进程的时间片用尽。
3. 当中断处理程序、系统调用或内核线程确定需要进行调度时（例如，一个高优先级任务被唤醒），会设置当前任务的 need_resched 标志。
4. 在即将返回用户空间或从中断返回之前，内核会检查此标志。如果该标志被设置，内核就会调用主调度函数 schedule() 来选择并切换到一个新的进程。

## schedule()
核心流程如下：
1. 调用调度类（如 CFS）的 pick_next_task() 方法来选择最应该运行的下一个任务。
2. 调用 context_switch() 函数，该函数负责大部分切换工作。
3. context_switch() 会调用 switch_mm() 来切换进程的虚拟地址空间（即加载新进程的页表），并调用 switch_to() 宏来切换处理器状态（寄存器和内核栈）。
4. switch_to() 是高度依赖体系结构的汇编代码，它完成了从旧进程到新进程的最后跳跃。

## 直接成本
通常以微秒（µs）为单位，大约在 2.7 到 5.5 微秒之间。   
1. 保存/恢复硬件上下文：CPU 必 须执行指令，将当前进程的寄存器值保存到其 task_struct（或内核栈）中，并加载新进程的寄存器值。   
2. 切换内核栈：内核的栈指针必须更新，以指向新进程的内核栈。switch_to() 宏通过操作栈来确保当它返回时，执行流会切换到新进程的上下文中。 
3. 切换页表目录：在 x86 架构上，CR3 寄存器必须被更新，以指向新进程的页表目录，这实际上切换了整个虚拟内存地址空间。   
4. TLB 刷新：更改地址空间会使地址转换后备缓冲失效。TLB 必须被刷新，这是一个昂贵的操作。
（1）在没有进程上下文标识符（PCID）支持的旧硬件上，每次切换地址空间（CR3 写入）都会导致整个TLB被刷新\
（2）现代 CPU 支持 PCID，允许 TLB 条目被标记上进程 ID，从而避免了在上下文切换时进行全局刷新，显著降低了这部分开销。
5. 调度器代码执行：CPU 用于执行调度器自身逻辑（以决定下一个运行哪个进程）所花费的时钟周期。   

## 间接成本
1. 常远大于直接成本，并且高度依赖于工作负载。
2. 新进程开始执行时，CPU 的各级缓存里面充满了前一个进程的数据和指令，对其是无用的。
3. 在执行初期会遭遇大量的缓存未命中，迫使其从速度慢得多的主内存中获取数据，这会显著降低其初始性能。
4. 这种效应在多核系统中会加剧。

## 量化与权衡
1. vmstat（cs列）或 pidstat 这样的工具可以用来测量系统上的上下文切换频率。
2. 小的时间片可以提高交互应用的响应速度，但会增加上下文切换开销在总 CPU 时间中的占比。
3. 一个普遍的经验法则是，将时间片大小设置在使上下文切换开销约占 CPU 时间的 1% 左右。

## 抢占模型