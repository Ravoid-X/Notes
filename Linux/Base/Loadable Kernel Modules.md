## 可加载内核模块（LKM）
1. Linux 内核采用模块化设计，允许在运行时动态地加载和卸载代码片段，而无需重新编译整个内核或重启系统。
2. 这些可动态加载的代码单元被称为可加载内核模块。
3. 这种机制极大地增强了内核的灵活性和可扩展性，使得内核可以保持一个较小的核心，同时按需加载功能。
4. 设备驱动程序是 LKM 最主要也是最常见的应用形式 。   

### 模块的初始化与清理
1. 每个内核模块都必须定义明确的入口和出口点，以便内核知道在加载和卸载模块时应执行哪些操作。
2. 这是通过 module_init() 和 module_exit() 宏来实现的。 
3. 两个宏是模块与内核之间的生命周期契约，是编写任何内核模块的强制性部分。
### module_init(init_function)
1. 这个宏指定了模块的初始化函数。当使用 insmod 或 modprobe 命令加载模块时，内核会调用这个被指定的 init_function。
2. 该函数负责执行所有必要的设置工作，如注册设备、分配资源等。如果初始化成功，它应返回 0；否则，返回一个负的错误码，模块加载将失败。
### module_exit(exit_function)
1. 这个宏指定了模块的清理函数。当使用 rmmod 命令卸载模块时，内核会调用这个 exit_function。
2. 该函数负责撤销初始化函数所做的一切工作，如注销设备、释放资源等，确保模块被干净地移除。

## 模块日常管理
Linux提供了一套标准的命令行工具来管理内核模块 。   
### lsmod
用于列出当前内核中所有已加载的模块。其输出通常包含三列：模块名称、模块大小以及使用该模块的其他模块（依赖关系）。   
### insmod
1. 基础命令，用于从指定的 .ko（Kernel Object）文件加载一个模块。
2. 不会自动处理模块的依赖关系，因此现在更推荐使用modprobe。 
### modprobe

### rmmod
1. 该命令用于卸载一个已加载的模块。
2. 如果模块的引用计数不为零（即仍有进程在使用该模块），卸载操作将会失败，以防止系统不稳定。   
### modinfo
该命令用于检查一个.ko文件，并显示其中包含的元数据信息，例如作者、描述、许可证、依赖项以及模块支持的参数等。   

## 日志系统
1. 在内核空间中，不能使用标准 C 库中的 printf 函数。取而代之的是 printk 函数，它是内核提供的标准日志记录机制。   
2. printk 函数将消息输出到内核的环形缓冲区中。用户空间的程序（如 dmesg）可以读取这个缓冲区来查看内核日志。
3. printk 支持日志级别，如 KERN_INFO, KERN_WARNING, KERN_ERR 等，这些级别决定了消息的重要程度，并允许在系统配置中对不同级别的消息进行过滤，这对于调试和监控至关重要。