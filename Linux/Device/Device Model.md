## 概述
Linux 2.6 内核引入了统一设备模型，提供了一个面向对象的框架，用于表示系统中设备、总线和驱动程序之间的物理和逻辑关系。
## kobject
设备模型的核心，本身不代表任何具体事物，而是作为一种“基类”嵌入到其他更高级的数据结构中，为它们提供一套标准化的功能。
### 引用计数 (kref)
1. 最核心的功能是通过其内嵌的 kref 结构来管理宿主对象的生命周期。
2. 每当有一个新的引用指向该对象时，引用计数通过 kobject_get() 增加
3. 引用释放时，通过 kobject_put() 减少。当引用计数降至零时，对象可以被安全地销毁。
### 层次结构
包含一个指向父 kobject 的指针，这使得所有内核对象能够组织成一个单一的树状层次结构。
### 用户空间表示
每个 kobject 都可以在 sysfs 虚拟文件系统中表现为一个目录，从而将内核对象暴露给用户空间。
## ktype
每个嵌入了 kobjec t的结构都必须关联一个 kobj_type。其定义了一类 kobject 的共同行为，主要包括
1. release 函数指针：当 kobject 的引用计数变为零时，这个函数会被调用，以释放包含 kobject 的宿主结构所占用的内存。
2. 指向 sysfs_ops 结构体的指针：该结构体定义了与此类对象关联的 sysfs 属性文件的读（show）和写（store）操作。
3. 默认属性列表（default_attrs）：定义了当此类型的 kobject 被创建时，应自动在 sysfs 中为其创建哪些属性文件。
## kset
1. 用于组织和管理一组相关 kobject 的容器，本身也包含一个 kobject。
2. 通常在 sysfs 中表现为一个目录，其包含的 kobject 则成为该目录下的子目录。
## sysfs
基于内存的虚拟文件系统，通常挂载在 /sys 下。作用是将内核内部的 kobject 层次结构以文件和目录的形式展现给用户空间。
### 目录与对象
每个注册到设备模型中的 kobject 通常都对应一个目录
### 文件与属性
1. 目录中的文件被称为 属性。对这些文件的读写操作会被内核截获，并转化为对驱动程序中预先注册的 show 和 store 函数的调用。
2. 用户空间读取属性文件时调用，驱动程序应将属性值格式化为字符串并写入 buf 中。sysfs 核心会分配一个大小为 PAGE_SIZE 的缓冲区 
```
show(struct kobject *kobj, struct attribute *attr, char *buf);   
```
3. 用户空间写入属性文件时调用，驱动程序应解析 buf 中的字符串以更新内部状态。
```
store(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count);
```
### 控制通路与数据通路
1. 用户程序通过 /dev 下的设备文件进行大数据流的传输（数据通路）
2. 通过 /sys 下的属性文件来进行设备状态的查询和参数的配置（控制通路）
3. 这种分离使得接口清晰，管理灵活
## struct device
1. 系统中所有设备的通用表示，物理硬件和虚拟设备都在内核中由一个 struct device 实例来代表。
2. 其本身嵌入了一个 kobject，还包含了指向其所属总线、父设备和绑定的驱动程序的指针。
## struct device_driver
1. 代表一个驱动程序，包含了驱动程序的名称、所属总线，以及一系列回调函数指针，其中最重要的是 probe 和 remove。
2. 本身并不与特定的设备实例绑定，而是作为一个能够管理一类设备的实体存在。
## struct bus_type
1. 连接处理器和设备（或其他总线）的通道。
2. 在设备模型中，struct bus_type代表一类总线，如pci_bus_type或usb_bus_type。总线驱动的核心职责之一是实现 match 函数。
## 驱动绑定
将一个设备与一个能够控制它的驱动程序关联起来的过程 。这个过程由设备模型核心自动触发
### 注册
当一个新设备被发现并注册到内核（调用 device_register()）时，或者一个新的驱动程序被加载并注册（调用 driver_register()）时，绑定过程开始。
### 匹配
1. 设备模型核心会遍历该设备所属总线上的所有驱动程序（或该驱动程序所属总线上的所有未绑定设备），并调用总线的 match 函数。
2. match 函数负责比较设备的 ID（如 PCI 的 Vendor/Device ID）和驱动程序支持的 ID 列表。
3. 如果 match 返回成功，则表示找到了一个合适的驱动 。   
### 探测 (probe)
1. 一旦找到匹配，设备模型核心就会调用驱动程序的 probe 函数，并将指向匹配的 struct device 的指针传递给它。
2. probe 函数是驱动程序真正的初始化入口。在这里，驱动程序会检查设备、请求硬件资源（I/O 端口、IRQ等）、初始化硬件，并准备好与设备进行通信。
3. 如果probe 成功，设备和驱动就正式“绑定”了。
### 移除 (remove)
1. 当设备被拔出或驱动程序被卸载时，驱动的 remove 函数会被调用。
2. 负责执行与 probe 相反的操作：释放资源、关闭硬件，完成清理工作。
## class：功能性的设备分组
用于将功能相似的设备组织在一起，无论它们连接在哪个总线上。
1. 例如，所有的输入设备（键盘、鼠标、触摸板）都属于 input 类；所有的硬盘和分区都属于 block 类。
2. 在 sysfs 中体现为 /sys/class/ 目录下的子目录（如 /sys/class/input, /sys/class/net）
### udev 协作
1. 当一个设备注册到一个 class 时，内核会发出一个 uevent 事件
2. 用户空间的守护进程 udev 会捕获这个事件，并根据预设的规则，在 /dev 目录下自动创建对应的设备文件节点。
3. 例如，为属于 input 类的设备创建 /dev/input/eventX，这极大地简化了设备文件的管理。