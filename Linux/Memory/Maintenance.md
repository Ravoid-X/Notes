## 概述
1. 为了保证系统在长时间运行和高负载下的稳定性和性能，内核必须具备动态调整和优化内存布局的能力。
2. 主要通过两个协同工作的机制实现：内存回收和内存规整。
## 水位线机制
### 水位
每个内存区域都定义了一套水位线机制，用于主动、分级地应对内存压力。主要有三个水位
1. pages_high：当区域内的空闲页数量高于此水位时，表明内存充足，回收机制可以休眠。
2. pages_low：当空闲页数量下降到此水位以下时，内核会唤醒 kswapd 内核守护进程，开始在后台异步地回收内存页 。   
3. pages_min：这是一个临界水位。当空闲页数量低于此水位时，表明内存压力已非常严重。此时，新的内存分配请求将无法被立即满足，请求内存的进程本身必须同步地、阻塞地执行内存回收操作 。
### 参数
根据区域大小动态计算，并且受到全局可调参数/proc/sys/vm/min_free_kbytes的影响。
## 页面分类
### 可移动
1. 主要是用户空间的匿名页和文件页（页缓存）。
2. 内核完全控制这些页面的页表映射，可以安全地迁移到新的物理位置，并更新页表即可。
### 不可移动
1. 大部分内核核心数据结构，如 slab 分配器分配的对象、进程内核栈、驱动程序的特定分配等。
2. 内核代码中可能存在直接指向这些页面物理地址的指针，移动它们会导致内核崩溃。
### 匿名页
1. 包括进程的堆 (Heap)、栈 (Stack) 以及通过 mmap 创建的私有匿名映射。
2. 这些页面没有文件作为后备存储，一旦被丢弃，数据就会丢失。
3. 在回收它们之前，必须先将其内容保存到交换空间。
### 文件页
磁盘缓存和程序代码段等，永远不会被写入交换空间。

# 内存回收
## 回收机制
根据内存压力的不同级别，内核采用 3 种不同的回收模式
### kswapd（后台异步回收）
1. 每个 NUMA 节点一个的内核线程。pages_low 时唤醒，开始扫描并回收内存页。
2. 在后台进行，对前台应用程序的延迟影响较小。会运行直到空闲页数量恢复到 pages_high 水位以上。
### 直接回收
1. 当一个进程请求内存，而系统空闲页低于 pages_min 时，该进程会被迫进入 直接回收。
2. 应用程序的执行会暂停，并由该进程的上下文同步执行内存回收算法，直到释放出足够的内存来满足其自身的分配请求。
### OOM Killer
1. 如果直接回收也无法释放出足够的内存，将启动。
2. 会根据一套启发式算法选择一个（或多个）“最不重要”的进程并将其杀死，以强制释放其占用的所有内存。
## 页面置换
### LRU（Least Recently Used）双链表
理想的策略是回收那些在未来最长时间内不会被访问的页面。由于无法预测未来，内核采用了一种近似 LRU 的算法，通过一个双链表系统来实现。
1. active_list：存放最近被访问过的页面。
2. inactive_list：存放长时间未被访问的“冷”页面，这些是回收的主要候选者。
### 机制
1. 一个新分配的或从磁盘读入的页面通常被放置在 inactive_list 的头部。
2. 当一个位于 inactive_list 上的页面被访问时，内核会设置其页描述符中的“引用”标志位（PG_referenced）。
3. 如果该页面被第二次访问，就会被“激活”，从 inactive_list 移动到 active_list 的头部。
4. kswapd 或直接回收过程主要扫描 inactive_list 的尾部来寻找可回收的页面。
5. 为了维持两个链表的动态平衡（通常 active_list 占总可回收页的大部分），内核会定期地将 active_list 尾部的页面移动到 inactive_list 的头部。\
（1）在这个过程中，内核会检查页面的引用标志位\
（2）如果引用位置位，说明该页面近期仍被使用，内核会清除该标志位，并将页面重新放回 active_list 的头部，给予其“第二次机会”。\
（3）如果引用位未置位，说明该页面在一段时间内未被访问，将其移动到 inactive_list。
### 成本效益原则
按以下顺序尝试回收不同类型的内存
1. 页缓存（文件页）：成本最低的回收对象。\
（1）未被修改文件页，可以直接丢弃，因为其内容可以从磁盘上重新读取。\
（2）已被修改文件页，必须先将其内容写回磁盘，然后才能释放。
2. Slab 缓存：可回收的内核对象缓存，如目录项和索引节点缓存，可以通过专门的“收缩器”机制来释放。
3. 匿名页：要回收必须先将内容写入到交换空间中，这个过程称为“换出”。由于涉及磁盘写操作，是成本最高的回收方式。

# 内存规整
1. 内存规整是应对外部碎片的关键机制，核心问题是总的空闲内存很多，但连续的空闲内存很少。
2. 原因是很多内核功能或驱动程序需要物理上连续的大块内存，以及存在大量对物理地址有直接依赖的数据结构（例如slab分配器中的对象指针）。
3. 目标是通过移动那些“可以移动”的页面，将被“钉子”分割开的空闲小块合并成一个大的连续空闲块。
## 双扫描器
### 迁移扫描器
从区域的低地址端开始向高地址扫描，目标是找到可移动的已分配页面。
### 空闲扫描器
从区域的高地址端开始向低地址扫描，的目标是找到空闲页面。
### 页面迁移
1. 两个扫描器均找到目标后，执行页面迁移操作。
2. 将已分配页面复制到空闲页面。不仅仅是内存拷贝，还必须原子地更新所有指向旧物理地址的页表条目，让它们指向新的物理地址。
3. 两个扫描器继续移动，直到它们相遇或交叉。
4. 最终在区域的低地址端整理出了一个巨大的连续空闲空间，可以满足高阶分配的需求。
5. 高阶分配：一次分配 $2^N$ 个页（N > 0）
## 触发机制
### 按需规整
1. 触发点: 当一个进程尝试进行高阶分配，但在伙伴系统中找不到合适的空闲块时，会触发直接回收。如果回收了一些内存后仍然无法满足，系统就会尝试进行按需规整。
2. 特性: 同步且阻塞，发起内存申请的进程会进入睡眠状态，等待规整完成。
3. 缺点: 会直接增加应用程序的延迟。如果规整过程很慢（例如需要迁移大量已修改页），可能会导致应用“卡顿”，甚至被看门狗杀掉。
4. 控制参数: /proc/sys/vm/extfrag_threshold 这个参数会影响是否触发规整。当这个值较高时，内核会更积极地进行规整来避免分配失败。
### 主动规整
1. 触发者: 内核线程 kcompactd。每个 NUMA 节点都有一个自己的 kcompactd 线程。
2. 触发时机: kcompactd 周期性地被唤醒，检查其所在节点的内存碎片化程度。如果碎片化程度超过了某个阈值，就会开始在后台进行规整工作。
3. 特性: 异步且非阻塞，在后台整理内存，目的是提前准备好连续内存，从而避免未来发生代价高昂的直接规整。
4. 控制参数: /proc/sys/vm/compaction/proactiveness 控制着 kcompactd 的积极程度。值越高，kcompactd 就会在内存碎片化程度还不太严重时就开始工作。
## 观察内存碎片化
### /proc/buddyinfo
1. 显示伙伴系统中每个阶的空闲块数量。
2. 如果高阶的空闲块为 0，但低阶的空闲块很多，说明存在严重的外部碎片。
### /proc/pagetypeinfo
1. 提供了非常详细的页面分类信息，可以看到每个区域中，Unmovable, Reclaimable, Movable 等类型的页面数量。
2. 通过观察 Unmovable 页面的分布，可以很好地理解碎片化的根源。
### /proc/vmstat
包含了内存规整相关的统计信息，例如：
1. compact_migrate_scanned: 迁移扫描器扫描过的页面数。
2. compact_free_scanned: 空闲扫描器扫描过的页面数。
3. compact_isolated: 为迁移而隔离的页面数。
4. compact_success, compact_fail: 规整成功和失败的次数。