## 概述
1. 应用程序开发者通常不直接与内核的页分配器交互，而是通过标准库函数（如 C 语言的 malloc()）或语言特性（如 C++ 的 new 操作符）来请求动态内存。
2. 这些用户空间的接口最终会通过系统调用与内核的内存管理子系统进行交互。
## 管理堆
1. 进程的动态内存存放于堆，内核通过一个名为“程序中断点”的指针来标记堆的末尾。
2. 用户空间可以通过两个相关的系统调用来调整这个中断点，从而改变堆的大小。
### brk()
brk(addr)：将程序中断点直接设置为指定的地址 addr 
### sbrk()
sbrk(x)：将程序中断点增加 x 字节（ x 可以为负数以缩小堆）
### 缺点
1. brk()/sbrk() 管理的是一个单一的、连续的内存区域，只有当堆顶部的内存被释放时，才能通过降低程序中断点将这部分内存真正返还给操作系统。
2. 如果堆中间的一大块内存被释放，但其上方仍有正在使用的内存，那么这块空闲的虚拟地址空间就无法被回收，造成 内存空洞。
3. 导致进程虚拟内存空间的 膨胀 和 碎片化 。
## 内存映射段：mmap()
1. 功能更强大灵活的系统调用，允许程序在进程的虚拟地址空间中创建一个新的、独立的内存映射区域。
2. mmap() 创建的区域可以位于地址空间的任何适当位置（通常在堆和栈之间）。
3. mmap() 创建的映射都是独立的，可以使用 munmap() 在任何时候单独解除映射，从而立即将其虚拟地址空间返还给内核。从根本上避免了碎片化。
### 类型
1. 文件映射：将一个文件或文件的一部分映射到内存。对这块内存的读写操作会直接反映到对应的文件上。这是加载动态链接库和实现高性能文件 I/O 的基础。   
2. 匿名映射：不与任何文件关联（通过指定 MAP_ANONYMOUS标志）。这块内存会被初始化为零，是向内核请求通用内存的现代方法。

## glibc 分配器
1. malloc(), free(), calloc(), realloc()等函数在 GNU/Linux 系统中，这由 glibc 库实现。
2. 其内部的内存分配器（称为 ptmalloc2）扮演着一个位于应用程序和内核之间的复杂内存管理器角色。
### malloc
系统调用（如 brk 和 mmap）是开销较高的操作，如果每次 malloc(16) 这样的小请求都触发一次系统调用，效率会极低。为了解决这个问题，glibc malloc采用了“批发-零售”的混合策略。
1. 对于小额分配\
（1）通过brk() 向内核“批发”一大块内存（例如 132KB），然后将其纳入自己的管理范围。\
（2）当应用程序请求小块内存时，从这个区域中“零售”出一小块，并使用内部数据结构（如“bins”或“arenas”）来跟踪已分配和空闲的块。\
（3）当调用 free() 时，内存通常只是被归还到 glibc 的空闲块链表中，而不是立即返还给内核。\
（4）后续的 malloc 请求就可以快速地从这些内部空闲块中得到满足，完全无需请求内核。
2. 对于大额分配\
（1）直接使用 mmap() 为该请求创建一个独立的匿名映射\
（2）好处是避免了用一个巨大的分配来污染或过度扩展主堆，防止了堆的碎片化\
（3）其次，当这块大内存被 free() 时，glibc 可以立即调用 munmap() 将其完整地返还给内核。
3. M_MMAP_THRESHOLD：决定使用 brk() 还是 mmap() 由 M_MMAP_THRESHOLD 参数控制\
（1）在早期，这是一个静态值，通常默认为 128KB\
（2）现代的 glibc 采用了动态阈值，是一种自适应的启发式策略\
（3）初始值仍为 128KB，但会根据程序的运行情况进行调整。\
（4）如当一个通过 mmap() 分配的大块内存被 free() 时，会调高 M_MMAP_THRESHOLD，使其等于或略大于刚被释放的块的大小。
### 代码
```
//定义要分配的内存大小，mmap 分配的长度通常是页大小的倍数
#include <sys/mman.h> // mmap, munmap
#include <unistd.h>   // sysconf, _SC_PAGE_SIZE
long page_size = sysconf(_SC_PAGE_SIZE);
if (page_size == -1) {
    perror("sysconf");
    return;
}
size_t length = 10 * page_size; // 分配 10 个页
void* mem = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
if (mem == MAP_FAILED) {
    perror("mmap");
    return;
}
//释放
if (munmap(mem, length) == -1) {
    perror("munmap");
    return;
}
```