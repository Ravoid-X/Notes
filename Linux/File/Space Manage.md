# 文件存储
## 连续分配 
最简单的方式，文件占用一组连续的磁盘块。提供了极佳的顺序读取性能，缺点是会产生外部碎片，并且文件增长困难。
## 非连续分配
### 链接分配
1. 数据块通过指针串联起来，像链表一样。FAT文件系统是其经典例子。
2. 解决了碎片问题，但对于随机访问性能极差。
### 索引分配
1. Inode 中包含一个指针数组，直接或间接地指向数据块。传统 Unix 文件系统（如 Ext2/Ext3）的标准做法。
2. 对于小文件，inode 直接包含数据块地址。对于大文件，则使用一级、二级甚至三级间接块，形成一个指向数据块的指针树。
### 区段
1. 索引分配的现代演进。元数据不再指向单个数据块，而是指向一个连续的块范围，由一个起始块号和一个长度值表示。
2. 极大地减少了存储大文件所需的元数据开销，并通过鼓励数据连续存放来提升性能和减少碎片。
3. Ext4 和 XFS均采用了此技术。
# 目录存储
## 线性/链接列表
1. 最简单的实现方式，目录项按顺序存储在一个列表中。
2. 查找、创建和删除操作都需要线性扫描整个列表，当目录中文件数量巨大时，性能会急剧下降。   
## 索引结构 (树)
### Hashed Trees
Ext4 采用的一种特殊的 B-tree。它以文件名的哈希值为键，将目录项组织起来，从而在大型目录中实现对数时间复杂度的查找。
### B+ Trees
XFS 和 Btrfs 采用的更为通用和强大的 B-tree 变体，为包含数百万个文件的超大型目录提供了卓越的性能和扩展性。
# 空闲空间管理
## 位图
1. 用一串比特位来表示所有磁盘块，每个比特位对应一个块（例如，1 代表已使用，0 代表空闲）。
2. 空间效率高，但在寻找大片连续空闲空间时，扫描效率不高。
3. Ext4 在其每个块组中都使用块位图和 inode 位图。
## 空闲列表/链表
1. 将所有未使用的块用指针链接成一个链表。
2. 实现简单，但容易导致空闲空间碎片化。
## B-tree
1. 最先进的方法，将空闲空间也组织成区段（起始块，长度），并用 B-tree 来索引这些空闲区段。
2. XFS 在每个分配组中使用一对 B+ 树，一个按起始块号索引，一个按区段长度索引。