### 引出
普通的实数运算时，$(a / b) * b = a$。但运算中所有数都是整数，运算结果也必须是整数。
### 例子
计算 $(10 / 2) % 3$
1. 正确计算：$10 / 2 = 5$，然后 $5 \% 3 = 2$。
2. 错误尝试：$(10 \% 3) / (2 \% 3)$，这等于 $1 / 2$，一个小数在模运算中是没有意义的。
### 模乘法逆元
1. 逆元 $b ^{−1}$\
$(b×b ^{−1} )(mod \ p)=1$
2. 除法转换成乘法\
$(a÷b)(mod \ p)≡(a×b^{−1} )(mod \ p)$
## 计算
### 费马小定理
当模数 p 是一个质数时，最常用、最简单的方法是费马小定理\
$b ^{−1}=b ^{p−2}$
### 快速幂 
1. $b ^{p−2}$不能直接计算，可能超时或溢出，使用快速幂算法加速\
2. 核心思想是利用指数的二进制。任何一个正整数 exp 都可以被写成 2 的幂次之和
3. 举例，计算 $a ^{13}$\
(1) 13 的二进制是 1101，转换为十进制的幂和。$13=1\times 2^3+1\times 2^2+0\times 2^1+1\times 2^0$\
(2)拆解幂运算，$a ^{13}=a ^{8+4+1}=a ^8\times a ^4\times a ^1$\
(3)每一项都是前一项的平方，可以不断地对底数进行平方并乘起来，就能得到结果
4. 代码
```
ll power(ll base, ll exp) {
    ll res = 1;
    base %= P;
    while (exp > 0) {
        // 如果是 1 ，说明最终结果需要乘以当前这一项的 base
        if (exp % 2 == 1) res = (res * base) % P;
        base = (base * base) % P;
        // 指数除以 2 ，相当于二进制右移一位，处理下一位
        exp /= 2;
    }
    return res;
}
ll modInverse(ll n) {
    return power(n, P - 2);
}
```
## 预运算阶乘
```
void precompute() {
    fact[0] = 1;
    invFact[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        fact[i] = (fact[i - 1] * i) % P;
    }
    // 先计算最大阶乘的逆元，然后反向递推，效率更高
    invFact[MAXN - 1] = modInverse(fact[MAXN - 1]);
    for (int i = MAXN - 2; i >= 1; i--) {
        invFact[i] = (invFact[i + 1] * (i + 1)) % P;
    }
}
```