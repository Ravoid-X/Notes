## 注意
处理包含指针或需要管理动态分配资源（如堆内存、文件句柄、网络连接等）的类时，才需要区分浅拷贝和深拷贝。
## 浅拷贝
1. 按位拷贝，简单地复制所有成员变量的值。如果包含了指针成员，只会复制指针的地址。
2. 如果没有为类显式定义拷贝构造函数和拷贝赋值运算符，C++ 编译器会自动生成一个浅拷贝版本。
### 举例
```
int* a = new int(10);
int* b = a;  // 浅拷贝：b 只是复制了 a 的指针
*b = 20;  // 修改 b 也会影响 a
```
### 问题
1. 悬挂指针（Dangling Pointer）：当其中一个对象被销毁后，另一个对象的指针 就成了一个悬挂指针，它指向一块已经被释放的、无效的内存。
2. 重复释放：当两个对象都被销毁时，它们会尝试释放同一块内存两次，这会导致程序崩溃。这是最常见也是最严重的问题。
3. 内存泄漏：如果在拷贝赋值操作中处理不当，也可能导致原有的内存没有被释放而造成内存泄漏。

## 深拷贝
在拷贝对象时，如果遇到指针成员，重新分配一块新的内存空间，然后将原指针所指向的内容完整地复制到这块新内存中。
### 实现方式
实现深拷贝，必须为类显式地定义：
1. 拷贝构造函数 (Copy Constructor)
2. 拷贝赋值运算符 (Copy Assignment Operator)
3. 析构函数 (Destructor)
### 举例
```
int* a = new int(10);
int* b = new int(*a);  // 深拷贝：创建新的 int 并复制值
*b = 20;  // 只改变 b，不影响 a
```
