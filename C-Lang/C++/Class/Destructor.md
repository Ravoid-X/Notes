## 析构函数
1. 在对象生命周期结束时自动运行，负责释放内存、关闭文件、断开网络连接等，防止资源泄漏。
2. 如果析构函数需要管理多个资源，应确保按照与资源分配相反的顺序释放资源。
3. 如果对象可能在多线程环境中被销毁，析构函数需要是线程安全的。需要额外的同步机制来防止资源竞争和数据不一致。
4. 当类在构造时获取了需要手动释放的资源时，必须自己实现析构函数
## 调用
### 栈对象
```
void func() {
    Widget w; // w 在栈上创建，构造函数被调用
    // ... 对 w 进行操作 ...
} // 函数结束，w 的析构函数 ~Widget() 在这里被自动调用
```
### 堆对象
```
void anotherFunction() {
    Widget* pW = new Widget(); // 在堆上创建对象，构造函数被调用
    // ... 使用 pW 指向的对象 ...
    delete pW; // 必须手动 delete！此时 ~Widget() 被调用，然后内存被释放
}
```
### 容器中的对象
如果对象是标准库容器（如 vector）的元素，当容器被销毁，或者该元素被从容器中移除（例如通过 pop_back() 或 erase()）时，该元素的析构函数会被调用。
### 临时对象
当一个临时对象被创建用于表达式求值时，它的析构函数会在包含该表达式的完整语句结束时被调用。
## 虚析构函数
```
class Base {
public:
    virtual ~Base() { /* ... */ } // 声明为虚析构函数
};

class Derived : public Base {
public:
    ~Derived() { /* ... */ }
};

Base* ptr = new Derived(); // 基类指针指向派生类对象
delete ptr; // 安全！
```
当通过一个基类指针去 delete 一个派生类对象时
1. 如果基类的析构函数是非虚的，delete ptr 只会调用 Base 类的析构函数。如果 Derived 类有自己的资源需要清理，就会导致资源泄漏。
2. 如果基类的析构函数是虚的，delete ptr 会首先调用 Derived 类的析构函数，然后自动调用 Base 类的析构函数。