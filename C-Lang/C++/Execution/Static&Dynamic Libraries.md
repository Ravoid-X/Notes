## 静态库
1. 在链接阶段，会将库中被调用的代码完整地复制到最终的可执行文件中
2. 文件扩展名:Linux/macOS: .a (Archive)；Windows: .lib (Library)
### 链接时流程
1. 编译：main.cpp 被编译成目标文件 main.o。
2. 链接：链接器在工作时，会把指定的静态库（比如 libmath.a）打开。
3. 复制：链接器从 libmath.a 中找到调用的函数（比如 sqrt），然后将其的二进制机器码复制到最终生成的可执行文件 app 中。
4. 完成：最终的 app 文件包含了 main.o 的代码和从 libmath.a 复制过来的代码。程序一旦生成，就和 libmath.a 文件再无关系。
### 优点
1. 部署简单，自给自足：生成的可执行文件包含了所有需要的代码，不依赖外部库，可以独立运行，移植非常方便。
2. 运行速度可能稍快：所有代码都在程序内部，运行时无需从外部加载，减少了启动开销。
### 缺点
1. 体积大：因为代码被复制了，如果多个程序都静态链接了同一个库，那么每个程序里都有一份拷贝，会浪费磁盘空间。
2. 更新困难：如果库文件有 Bug 需要修复或升级，必须重新编译所有链接了这个库的程序。

## 动态库
1. 在链接阶段不复制代码，只在可执行文件中记录一个引用。真正的链接发生在程序运行时。
2. 文件扩展名:Linux: .so (Shared Object)；macOS: .dylib (Dynamic Library)；Windows: .dll (Dynamic-Link Library)
### 链接时流程
1. 编译：main.cpp 被编译成目标文件 main.o。
2. 链接：链接器看到指定的动态库（如 libmath.so），它不会复制库代码，只会在最终的可执行文件 app 中加入一些标记信息。
3. 运行：当执行 ./app 时，操作系统的加载器 (Loader) 会检查 app 的标记信息。
4. 加载：加载器发现 app 需要 libmath.so，于是就把 libmath.so 加载到内存中。
5. 链接：解析 app 中对 sqrt 函数的调用，使其指向内存中 libmath.so 里 sqrt 函数的真实地址。这个过程才是真正的链接。