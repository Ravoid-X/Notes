## 定义
1. CPU一次只能执行一条指令。
2. 假定两个操作 A 和 B，如果从执行 A 的线程来看，当另一个线程执行 B 时，要么将 B 全部执行完，要么完全不执行 B，那么 A 和 B 对彼此来说是原子的。
## 引出
1. "i++"的操作，经过编译翻译成汇编语言后成了三句汇编代码
```
__asm__{
    mov eax [i]	//将变量i的值取出到cpu寄存器eax中
    inc eax		//eax自增1
    mov [i] eax	//将寄存器eax的值写入内存变量i的地址中
}
```
2. 在多线程环境下，这三条汇编指令可能未执行完，就因为 cpu 时间片结束了导致线程切换，被其他的线程获取值后修改了。
3. 除了加锁外，还有那就是原子操作可以解决此问题，其需要硬件的支持，不过大部分的电脑都支持。

## 实现
### 汇编指令 lock
通过 lock 指令锁住 cpu 总线，使这多句汇编代码变成一句不可分割的指令
```
int inc(int* value, int add) {
	int old;
    __asm__ volatile (
         "lock; xaddl %2, %1;"   // 指令1：lock; 指令2: xaddl, 操作数占位符：%1, %2
         : "=a" (old)            // 输出：结果放入通用寄存器eax
         : "m" (*value), "a" (add)   // 输入：操作数1（内存），操作数2（寄存器eax）
         : "cc", "memory"            // 编译方式，内存
     );
    return old;
}
```
### CAS

### `#include <atomic>`