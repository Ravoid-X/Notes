## 特性
1. 引用可以更方便地操作变量，而不需要通过复杂的指针运算，本质上是一种别名机制。
2. 必须初始化，且一旦与某个变量绑定，就不可能更改。
3. 在使用引用时，不需要像指针那样显式地解引用。编译器会在使用引用时自动处理它。
4. 一个变量可以有多个引用，一个引用可以继续有引用。

## 使用场景（左值引用）
主要作用是避免对象拷贝
### 函数参数
1. 在函数内部会对此参数进行修改
2. 提高函数调用和运行效率
```
void swap(int &p1,int &p2){
    int temp = p1;
    p1 = p2;
    p2 = temp;
}
```
### 返回值
1. 将函数中的临时变量返回时，无论这个变量是在栈区、堆区或者静态区，都会通过一个临时变量去充当返回值。
2. 小一点的话可能是寄存器 eax，大一点可能是在上一层栈帧开好的。
3. 引用返回可以免去这种拷贝的过程，主要用于像静态变量、全局变量等这些出了作用域不会销毁的对象
```
int& Count(){
	static int n = 0;
	n++;
	return n;
}
```
## 右值引用
主要作用是延长对象的生命周期，识别出表达式中的右值，以便进行特殊的、更高效的操作。
### 引出
1. 在 C++11 之前只有左值引用。但有一个“缺陷”：普通的左值引用不能绑定到右值，只有 const 左值引用可以。
2. 无法在函数重载时专门区分出传入的参数是“持久的左值”还是“临时的右值”
```
int& r1 = 10; // 错误！普通左值引用不能绑定到右值
const int& r2 = 10; // 正确。const 左值引用可以“延长”右值的生命周期
```
3. 为了解决这个问题，C++11 引入了右值引用 &&
### 举例
```
int x = 10,y = 10;
int&& rr1 = 10;             // 正确！右值引用绑定到右值
int&& rr2 = x + y;          // 正确！

string getName() { return "00"; }// 返回值是一个右值
string&& rr3 = getName(); // 正确！

int&& rr4 = x;              // 错误！右值引用不能绑定到左值 x
```
### 实现移动语义
```
A(A&& a) {
    this->data_ = a.data_;
    a.data_ = nullptr;
}
//move 本身不做任何移动操作，只是一个类型转换
//将一个左值强制转换为右值引用，从而让它能够匹配移动构造函数或移动赋值运算符
A b = move(a);
```
### 万能引用（转发引用）
可以接受左值或右值的引用，为了实现完美转发
```
template<typename T>
void func(T&& arg) {
    \\...
}
```
### 实现完美转发
指一个函数模板能够将其接收到的参数，以原始的值类别（左值或右值），原封不动地转发给另一个函数。
### 问题
```
template<typename T>
void print(T & t){
    std::cout << "Lvalue ref" << std::endl;
}

template<typename T>
void print(T && t){
    std::cout << "Rvalue ref" << std::endl;
}

template<typename T>
void testForward(T && v){ 
    //虽然 v 是右值，但此时在内存中已有位置，所以其实是左值
    print(v); 
    print(forward<T>(v)); 
    print(move(v)); //永远调用右值版本的print
}

int main(){
    int x = 1;
    testForward(x); //实参为左值
    testForward(std::move(x)); //实参为右值
}
```
```
Lvalue ref
Lvalue ref
Rvalue ref
======================
Lvalue ref
Rvalue ref
Rvalue ref
======================
```
左值右值在函数调用时，都转化成了左值，使得函数转调用时无法判断左值和右值。
### `forward<T>`

## 常引用
### 权限放大：报错
```
const int a = 2;
int& b = a;
```
### 权限保持：可行
```
const int a = 2;
const int& b = a;
```
### 权限缩小：可行
```
int a = 2;
const int& b = a;
```

## 临时变量具有常性
### 类型转换
1. 不报错，只会丢失精度
```
double a = 2.2;
int b = a;
```
2. 报错
```
double a = 2.2;
int& b = a;
```
3. 不报错，引用了类型转换后的临时变量，而不是 a
```
double a = 2.2;
const int& b = a;
```

## 引用的引用
严格符合标准的编译器是不允许直接定义引用的引用的而只允许间接定义。
```
int x = 10;
int& r = x;   
int& & rr = r;   // 编译错误
```
### 引用折叠
在某些现代 C++ 的场景中（主要是模板和 auto 类型推导），编译器在内部会遇到“引用的引用”。此时，会遵循一个叫做 “引用折叠” 的规则。
1. T& &   -> T&   (对左值引用的左值引用，折叠成左值引用)
2. T& &&  -> T&   (对左值引用的右值引用，折叠成左值引用)
3. T&& &  -> T&   (对右值引用的左值引用，折叠成左值引用)
4. T&& && -> T&&  (对右值引用的右值引用，折叠成右值引用)