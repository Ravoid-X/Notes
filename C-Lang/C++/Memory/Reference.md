## 特性
1. 引用可以更方便地操作变量，而不需要通过复杂的指针运算，本质上是一种别名机制。
2. 必须初始化，且一旦与某个变量绑定，就不可能更改。
3. 在使用引用时，不需要像指针那样显式地解引用。编译器会在使用引用时自动处理它。
4. 一个变量可以有多个引用，一个引用可以继续有引用。

## 使用场景（左值引用）
主要作用是避免对象拷贝
### 函数参数
1. 在函数内部会对此参数进行修改
2. 提高函数调用和运行效率
```
void swap(int &p1,int &p2){
    int temp = p1;
    p1 = p2;
    p2 = temp;
}
```
### 返回值
1. 将函数中的临时变量返回时，无论这个变量是在栈区、堆区或者静态区，都会通过一个临时变量去充当返回值。
2. 小一点的话可能是寄存器 eax，大一点可能是在上一层栈帧开好的。
3. 引用返回可以免去这种拷贝的过程，主要用于像静态变量、全局变量等这些出了作用域不会销毁的对象
```
int& Count(){
	static int n = 0;
	n++;
	return n;
}
```
## 右值引用
主要作用是延长对象的生命周期，识别出表达式中的右值，以便进行特殊的、更高效的操作。
### 引出
1. 在 C++11 之前只有左值引用。但有一个“缺陷”：普通的左值引用不能绑定到右值，只有 const 左值引用可以。
2. 无法在函数重载时专门区分出传入的参数是“持久的左值”还是“临时的右值”
```
int& r1 = 10; // 错误！普通左值引用不能绑定到右值
const int& r2 = 10; // 正确。const 左值引用可以“延长”右值的生命周期
```
3. 为了解决这个问题，C++11 引入了右值引用 &&
### 举例
```
int x = 10,y = 10;
int&& rr1 = 10;             // 正确！右值引用绑定到右值
int&& rr2 = x + y;          // 正确！

string getName() { return "00"; }// 返回值是一个右值
string&& rr3 = getName(); // 正确！

int&& rr4 = x;              // 错误！右值引用不能绑定到左值 x
```
### 实现移动语义

### 实现完美转发


## 常引用
### 权限放大：报错
```
const int a = 2;
int& b = a;
```
### 权限保持：可行
```
const int a = 2;
const int& b = a;
```
### 权限缩小：可行
```
int a = 2;
const int& b = a;
```

## 临时变量具有常性
### 类型转换
1. 不报错，只会丢失精度
```
double a = 2.2;
int b = a;
```
2. 报错
```
double a = 2.2;
int& b = a;
```
3. 不报错，引用了类型转换后的临时变量，而不是 a
```
double a = 2.2;
const int& b = a;
```

## 引用的引用
严格符合标准的编译器是不允许直接定义引用的引用的而只允许间接定义。
```
int x = 10;
int& r = x;   
int& & rr = r;   // 编译错误
```
### 引用折叠
在某些现代 C++ 的场景中（主要是模板和 auto 类型推导），编译器在内部会遇到“引用的引用”。此时，会遵循一个叫做 “引用折叠” 的规则。
1. T& &   -> T&   (对左值引用的左值引用，折叠成左值引用)
2. T& &&  -> T&   (对左值引用的右值引用，折叠成左值引用)
3. T&& &  -> T&   (对右值引用的左值引用，折叠成左值引用)
4. T&& && -> T&&  (对右值引用的右值引用，折叠成右值引用)